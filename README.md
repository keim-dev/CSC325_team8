# CSC325_team8
In order to run each design you must first run the MAIN.java file. The code will prompt user input in which you can choose whether to test one design or both with the test methods in the MAIN file.

Design Rationale:
    For this project the interface design was easier to do than the abstract design for one main reason, the lack of shape object types. The interfaces feel more bare bones because I can only put methods without bodies in them, forcing me to write out the method's behavior for each individual shape class where as that could be prefilled with a common behavior in an abstract and then overridden later if a class needs the behavior to differ.
    In terms of scaling it really depends on which way the code is being scaled. If you want to add more functionality for each shape (like a larger number of implementable methods) then interfaces would be the way to go, you can implement several different interfaces that do completely different things depending on the class yet still make sense semantically making it more readable. However if you want to add more objects or shape types then an abstract class would be the way to go. You can do the same things as an interface but also add some methods with bodies to reduce redundancy and increase efficiency in ways that aren't possible with an interface. Although you cannot extend multiple abstract classes you can still do tiered inheritance with them or simply add an interface to your code if you want an extra method that does not fit the bounds of the abstract class. 

    In a real system i would use the abstract approach due to the increased versatility that comes with it and the potential for less redundancy. If I'm creating more than 3 methods and objects then the interface approach would not only take considerably longer but would also be more repetitive and annoying to write. The only case I would solely interfaces over solely abstract classes is if I have multiple object types with similar actions but unique behaviors.

AI:
    AI was used for two functions on this assignment. First was as a suggestion tool when writing individual lines, if a suggestion by copilot matched my desired syntax patterns and naming schemes then it was used to finish the single line being worked on. The second function was to type all javadoc comments. Occasionally the suggestions by copilot would incorrectly call the methods or use an incorrect object name (at max happened 5 times), I found no issues with the generated javadoc comments.